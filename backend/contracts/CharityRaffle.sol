// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";
import "@chainlink/contracts/src/v0.8/ConfirmedOwner.sol";
import "@chainlink/contracts/src/v0.8/AutomationCompatible.sol";

contract CharityRaffle is VRFConsumerBaseV2, ConfirmedOwner, AutomationCompatibleInterface {
    enum RaffleStatus {
        OPEN,
        CALCULATING,
        END
    }
    struct Raffle {
        address payable charityAddr;
        string description;
        uint256 endTime;
        RaffleStatus raffleStatus;
        address[] players;
        address payable winner;
        uint256 raffleBalance;
    }

    uint256 lastRaffleId;
    mapping(uint256 => Raffle) raffles;
    VRFCoordinatorV2Interface COORDINATOR;
    uint64 s_subscriptionId;

    //key hash for gas lane
    bytes32 keyHash =
        //0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15;
        //https://docs.chain.link/vrf/v2/subscription/supported-networks#avalanche-fuji-testnet
        0x354d2f95da55398f44b7cff77da56283d9c6c829a4bdf1bbcaf2ad6a4d081f61;
    uint32 callbackGasLimit = 100000;
    uint16 requestConfirmations = 3;
    uint32 numWords = 1;

    uint256 lastTimeStamp;
    uint256 public randomNum;

    /**
     * HARDCODED FOR GOERLI
     * COORDINATOR: 0x2Ca8E0C643bDe4C2E08ab1fA0da3401AdAD7734D
     * Avalanche Fuji testnet
     * COORDINATOR: 0x2eD832Ba664535e5886b75D64C46EB9a228C2610
     */
    event RequestFulfilled(uint256 requestId, uint256[] randomWords);
    event RaffleCreated(uint256 raffleId, address charity, uint256 endTime);
    event RaffleBought(address buyer, uint256 raffleId);

    constructor(
        uint64 subscriptionId
    )
        VRFConsumerBaseV2(0x2eD832Ba664535e5886b75D64C46EB9a228C2610)
        ConfirmedOwner(msg.sender)
    {
        COORDINATOR = VRFCoordinatorV2Interface(
            0x2eD832Ba664535e5886b75D64C46EB9a228C2610
        );
        s_subscriptionId = subscriptionId;
    }

    function createRaffle(address payable charityAddr, string calldata description, uint256 endTime) external onlyOwner{
        uint256 raffleId = lastRaffleId;
        raffles[raffleId].charityAddr = charityAddr;
        raffles[raffleId].description = description;
        raffles[raffleId].endTime = endTime;
        emit RaffleCreated(raffleId, charityAddr, endTime);
        lastRaffleId++;
    }

    function buyRaffle(uint256 raffleId) external payable {
        raffles[raffleId].players.push(msg.sender);
        raffles[raffleId].raffleBalance += msg.value;
        emit RaffleBought(msg.sender, raffleId);
    }

    function pickWinner()
        external
        onlyOwner
        returns (uint256 requestId)
    {
        requestId = COORDINATOR.requestRandomWords(
            keyHash,
            s_subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numWords
        );
        return requestId;
    }

    function fulfillRandomWords(
        uint256 _requestId,
        uint256[] memory _randomWords
    ) internal override {
        emit RequestFulfilled(_requestId, _randomWords);
        randomNum = _randomWords[0];
    }

    function makePayments(uint256 raffleId, address charityAddr, address winner) public {
        uint256 raffleBalance = raffles[raffleId].raffleBalance;
        uint256 toCharity = (raffleBalance * 45) / 100;
        uint256 toWinner = (raffleBalance * 45) / 100;
        raffles[raffleId].raffleBalance -= toCharity;
        raffles[raffleId].raffleBalance -= toWinner;
        (bool sentCharity,) = payable(charityAddr).call{value: toCharity}("");
        require(sentCharity, "sent to Charity failed");
        (bool sentWinner,) = payable(winner).call{value: toWinner}("");
        require(sentWinner, "sent to winner failed");
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {
        //upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        // if ((block.timestamp - lastTimeStamp) > interval) {
        //     lastTimeStamp = block.timestamp;
        //     counter = counter + 1;
        // }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

    function getContractBalance() external view returns(uint256) {
        return address(this).balance;
    }

    function withdrawBalance() external onlyOwner{
        uint256 balance = address(this).balance;
        (bool sent, ) = payable(msg.sender).call{value: balance}("");
        require(sent, "sent balance failed");
    }
}
